/**
 * @exclude
 * === HACK HACK HACK ===
 *
 * The existence of Host_nojson.proto is because if we bring in all the
 * k8s.io types that we would want to, the generated *.pb.json.go files try
 * to import github.com/gogo/protobuf/jsonpb, and that turns out to crash on
 * some of the k8s.io types. Sigh.
 *
 * So, instead, we split out the minimal high-level stuff we need in most of
 * of the Go code into Host_nojson.proto, and leave the more detailed things
 * with the breaking types here. For more information on this brutality, see
 * https://github.com/datawire/ambassador/pull/1999#issuecomment-548939518.
 *
 * === end hack ===
 *
 * Host defines a way that an Ambassador will be visible to the
 * outside world. A minimal Host defines a hostname (of course) by
 * which the Ambassador will be reachable, but a Host can also
 * tell an Ambassador how to manage TLS, and which resources to 
 * examine for further configuration.
 */
syntax = "proto3";

package getambassador.io.v2;

import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/api/core/v1/generated.proto";
import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";

/**
The custom `Host` resource defines how the Ambassador Edge Stack will be visible to the outside world. It collects all the following information in a single configuration resource:

* The hostname by which Ambassador will be reachable
* How Ambassador should handle TLS certificates
* How Ambassador should handle secure and insecure requests
* Which resources to examine for further configuration

A minimal Host resource, using Let’s Encrypt to handle TLS, would be:

```yaml
apiVersion: getambassador.io/v2
kind: Host
metadata:
  name: minimal-host
spec:
  hostname: host.example.com
  acmeProvider:
    email: julian@example.com
```

This Host tells Ambassador to expect to be reached at `host.example.com`, and to manage TLS certificates using Let’s Encrypt, registering as `julian@example.com`. Since it doesn’t specify otherwise, requests using cleartext will be automatically redirected to use HTTPS, and Ambassador will not search for any specific further configuration resources related to this Host.
 */
message HostSpec {
  // Common to all Ambassador objects (and optional).
  repeated string ambassador_id = 1;

  // Common to all Ambassador objects (and optional).
  int32 generation = 2;

  // Hostname by which the Ambassador can be reached.
  string hostname = 3;

  // Selector by which we can find further configuration. Defaults to hostname=$hostname
  k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;

  // Specifies who to talk ACME with to get certs. Defaults to Let's Encrypt; if "none", do
  // not try to do TLS for this Host.
  ACMEProviderSpec acmeProvider = 5; // The acmeProvider element in a Host defines how Ambassador should handle TLS certificates

  // Name of the Kubernetes secret into which to save generated certificates. Defaults
  // to $hostname
  k8s.io.api.core.v1.LocalObjectReference tlsSecret = 6;

  // Request policy definition.
  RequestPolicy requestPolicy = 7;
}

enum HostTLSCertificateSource {
  Unknown = 0;
  None    = 1;
  Other   = 2;
  ACME    = 3;
}

enum HostState {
  // The default value is the "zero" value, and it would be great if
  // "Pending" could be the default value; but it's Important that the
  // "zero" value be able to be shown as empty/omitted from display,
  // and we really do want `kubectl get hosts` to say "Pending" in the
  // "STATE" column, and not leave the column empty.
  Initial = 0;
  Pending = 1;
  Ready   = 2;
  Error   = 3;
}

enum HostPhase {
  NA                        = 0;
  DefaultsFilled            = 1;
  ACMEUserPrivateKeyCreated = 2;
  ACMEUserRegistered        = 3;
  ACMECertificateChallenge  = 4;
}

message HostStatus {
  HostTLSCertificateSource tlsCertificateSource = 1;

  HostState state = 2;

  // phaseCompleted and phasePending are valid when state==Pending or
  // state==Error.
  HostPhase phaseCompleted = 3;
  HostPhase phasePending = 4;

  // errorReason, errorTimestamp, and errorBackoff are valid when state==Error.
  string errorReason = 5;
  google.protobuf.Timestamp errorTimestamp = 6 [(gogoproto.stdtime) = true];
  google.protobuf.Duration errorBackoff = 7 [(gogoproto.stdduration) = true];
}

/**
The acmeProvider element in a Host defines how Ambassador should handle TLS certificates:

```yaml
acmeProvider:
  authority: url-to-provider
  email: email-of-registrant
tlsSecret:
  name: secret-name
```

* In general, `email-of-registrant` is mandatory when using ACME: it should be a valid email address that will reach someone responsible for certificate management.
* ACME stores certificates in Kubernetes secrets. The name of the secret can be set using the `tlsSecret` element; if not supplied, a name will be automatically generated from the `hostname` and `email`.
* If the authority is not supplied, the Let’s Encrypt production environment is assumed.
* **If the authority is the literal string “none”, TLS certificate management will be disabled.** You’ll need to manually create a TLSContext to use for your host in order to use HTTPS.
 */
message ACMEProviderSpec {
  // Specifies who to talk ACME with to get certs. Defaults to Let's
  // Encrypt; if "none", do not try to do TLS for this Host.
  string authority = 1;

  string email = 2;

  k8s.io.api.core.v1.LocalObjectReference privateKeySecret = 3;

  // This is normally set automatically
  string registration = 4;
}

/**
A **secure** request arrives via HTTPS; an **insecure** request does not. By default, secure requests will be routed and insecure requests will be redirected (using an HTTP 301 response) to HTTPS. The behavior of insecure requests can be overridden using the `requestPolicy` element of a Host:

```yaml
requestPolicy:
  insecure:
    action: insecure-action
    additionalPort: insecure-port
```
 */
message RequestPolicy {
  // How shall we handle insecure requests?
  InsecureRequestPolicy insecure = 1;

  // Later we may define a 'secure' section too.
}

/**
The `insecure-action` can be one of:

* `Redirect` (the default): redirect to HTTPS
* `Route`: go ahead and route as normal; this will allow handling HTTP requests normally
* `Reject`: reject the request with a 400 response

The `additionalPort` element tells Ambassador to listen on the specified `insecure-port` and treat any request arriving on that port as insecure. **By default, `additionalPort` will be set to 8080 for any `Host` using TLS.** To disable this redirection entirely, set `additionalPort` explicitly to `-1`:

```yaml
requestPolicy:
  insecure:
    additionalPort: -1   # This is how to disable the default redirection from 8080.
```

Some special cases to be aware of here:

* **Case matters in the actions:** you must use e.g. `Reject`, not `reject`.
* The `X-Forwarded-Proto` header is honored when determining whether a request is secure or insecure. For more information, see "Load Balancers, the `Host` Resource, and `X-Forwarded-Proto`" below.
* ACME challenges with prefix `/.well-known/acme-challenge/` are always forced to be considered insecure, since they are not supposed to arrive over HTTPS.
* Ambassador Edge Stack provides native handling of ACME challenges. If you are using this support, Ambassador will automatically arrange for insecure ACME challenges to be handled correctly. If you are handling ACME yourself - as you must when running Ambassador Open Source - you will need to supply appropriate Host resources and Mappings to correctly direct ACME challenges to your ACME challenge handler.
 */
message InsecureRequestPolicy {
  // What action should be taken for an insecure request?
  InsecureRequestAction action = 1;

  // Is there an additional insecure port we should listen on?
  int32 additionalPort = 2;
}

enum InsecureRequestAction {
  Redirect = 0;
  Reject   = 1;
  Route    = 2;
}
